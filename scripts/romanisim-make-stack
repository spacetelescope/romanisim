#!/usr/bin/env python

import argparse
from copy import deepcopy
from astropy.coordinates import SkyCoord
from astropy import units as u
from astropy.table import Table
from astropy.time import Time
import galsim
from romanisim import wcs, persistence, log, parameters
from romanisim.parameters import default_parameters_dictionary
import ris_make_utils as ris


def main():
    parser = argparse.ArgumentParser(
        description='Make a stack of demo images.',
        epilog='EXAMPLE: %(prog)s mosaic_list.csv',
        formatter_class=argparse.ArgumentDefaultsHelpFormatter)

    # Command line Argument
    parser.add_argument('input_file_name',
                        type=str,
                        metavar='mosaic_list.csv',
                        help='Input (csv) file containing lists of observation parameters: '
                             'ra, dec, roll_angle, optical_element, date, overhead_time, '
                             'ms_table_number')

    # Boresight
    parser.add_argument('-b', '--boresight',
                        action='store_true',
                        help=('RA & Dec specifies location of boresight, not center of WFI.'))

    # WCS Object Catalog
    parser.add_argument('-c', '--catalog',
                        type=str,
                        metavar='object_table.csv',
                        default=None,
                        help='Object catalog file for wcs matching (csv)')

    # Date & Time argument
    parser.add_argument('-d', '--date',
                        type=str,
                        default='2026-01-01T00:00:00',
                        help=('UTC Date and Time of observation to simulate in ISOT format.'))

    # Level argument
    parser.add_argument('-l', '--level',
                        type=int,
                        default=1,
                        help='1 or 2, for L1 or L2 output')

    # Create script making argument
    parser.add_argument('-m', "--make_script",
                        type=str,
                        metavar='sims',
                        default=None,
                        help='Filename to output catalog (sims.cat) and list of romanisim calls '
                             '(sims.script) instead of making simulation files (e.g. for cluster '
                             'usage).')

    # Number of objects to simulate
    parser.add_argument('-n', '--nobj',
                        type=int,
                        default=1000,
                        help='Specify number of objects to simulate.')

    # Create script making argument
    parser.add_argument('-x', "--prefix",
                        type=str,
                        metavar='roman_simulated',
                        default='roman_simulated',
                        help='Filename prefix for simulated files.')

    # Persistence
    parser.add_argument('-p', '--persistence',
                        action='store_true',
                        help=(
                            'Enable persistence modeling of previous files for exposures after the first in each SCA.'))

    # Random number seed
    parser.add_argument('-r', '--rng_seed',
                        type=int,
                        default=None,
                        help='Random number seed (int)')

    # SCA detector identifier number
    parser.add_argument('-s', '--sca',
                        type=int,
                        default=0,
                        help='SCA to simulate')

    # Use CRDS for distortion maps
    parser.add_argument('-u', '--usecrds',
                        action='store_true',
                        help='Use CRDS for distortion map')

    # Use CRDS stored PSFs
    parser.add_argument('-w', '--webbpsf',
                        action='store_true',
                        help='Use webbpsf for PSFs.')

    args = parser.parse_args()

    log.info('Starting simulation...')
    log.warning("romanisim is under active development.  Its output has "
                "not been formally validated; only limited testing has been "
                "performed.  For this reason, use of romanisim for "
                "preparation of ROSES proposals is not advised.  Other "
                "packages like galsim's roman package or STIPS may better "
                "serve such purposes.")

    # Set up metadata
    metadata = deepcopy(default_parameters_dictionary)

    # Obtain pointing information from input file
    pointings = Table.read(args.input_file_name, comment="#", delimiter=" ")

    # Obtain RA & Dec pointing extremes from the catalog
    max_ra = max(pointings["RA"])
    min_ra = min(pointings["RA"])
    ra_center = (max_ra + min_ra) / 2
    metadata['wcsinfo']['ra_ref'] = ra_center
    max_dec = max(pointings["DEC"])
    min_dec = min(pointings["DEC"])
    dec_center = (max_dec + min_dec) / 2
    metadata['wcsinfo']['dec_ref'] = dec_center
    ra_diff = max_ra - min_ra
    dec_diff = max_dec - min_dec

    log.debug(f"max_ra = {max_ra}"
              f"min_ra = {min_ra}"
              f"ra_diff = {ra_diff}"
              f"max_dec = {max_dec}"
              f"min_dec = {min_dec}"
              f"dec_diff = {dec_diff}")

    # Create random number distribution
    rng = galsim.UniformDeviate(args.rng_seed)

    # Calculate radius to span the entire FOV (degrees)
    radius = max([ra_diff, dec_diff]) + parameters.WFS_FOV

    log.debug(f"radius = {radius}")

    # Create catalog
    cat = ris.create_catalog(metadata=metadata, catalog_name=args.catalog,
                             bandpasses=pointings['BANDPASS'], rng=rng, nobj=args.nobj,
                             usecrds=args.usecrds, x=(ra_center * galsim.degrees),
                             y=(dec_center * galsim.degrees), radius=radius)

    # If creating a script, create the catalog and script files
    if args.make_script:
        # Write catalog file
        if not args.catalog:
            cat.write(args.make_script + "_cat.csv", format='ascii.ecsv', overwrite=True)

        # Create script file
        script_file = open(args.make_script + ".script", "w")

        # Acquire cleaned options to pass to script call
        options_dct = {}
        for option, value in vars(args).items():
            log.debug(f'option, value = {option, value}')
            if option not in ('input_file_name', 'debug', 'make_script') and \
                    value is not None:
                options_dct[option] = value

    # Initialize time offset
    time_offset = 0.0 * u.s

    # Set file name suffix
    suffix = "uncal" if (args.level == 1) else "cal"

    # If selected, reset persistence dictionary
    if args.persistence:
        previous_file_name = {}

    # Loop over pointings
    for entry_idx, entry in enumerate(pointings):

        # Debug: print keys
        log.debug(f'entry.keys = {entry.keys()}')

        # Set initial (possibly only) SCA
        sca = args.sca if (args.sca > 0) else 1

        # If SCA value is within 1-18, only run once
        # otherwise loop over all detectors
        while (sca <= parameters.NUMBER_OF_DETECTORS):
            # Create output file name
            output_file_name = f"{args.prefix}_{entry_idx}_{entry['BANDPASS']}_WFI{sca:02}_{suffix}.asdf"

            log.debug(f"output_file_name = {output_file_name}")

            # If making a script, write the line and proceed
            # otherwise create simulation file
            if args.make_script:
                line = f"romanisim-make-image {output_file_name}"

                for option, value in options_dct.items():
                    if (type(value) != bool) and (option != 'sca') and (option != 'prefix') and (option != 'persistence'):
                        line += f" --{option} {value}"
                    elif (option == 'persistence') and (sca in previous_file_name.keys()):
                        line += f" --{option} {previous_file_name[sca]}"
                    elif (option == 'sca'):
                        line += f" --{option} {sca}"
                    elif (value is True) and (option != 'persistence'):
                        line += f" --{option}"

                line += f" --bandpass {entry['BANDPASS']}"
                line += f" --radec {entry['RA']} {entry['DEC']}"
                line += f" --roll {entry['PA']}"
                line += f" --ma_table_number {entry['MA_TABLE_NUMBER']}"
                line += f" --catalog {args.make_script}_cat.csv"

                # Debug print line
                log.debug(f'line = {line}')

                # add line to script
                script_file.write(line + '\n')

            else:
                # RA & Dec
                log.debug(f"float(entry['PA']) = {float(entry['PA'])}")
                coord = SkyCoord(ra=float(entry['RA']) * u.deg, dec=float(entry['DEC']) * u.deg,
                                 frame='icrs')
                wcs.fill_in_parameters(metadata, coord, boresight=args.boresight,
                                       roll_ref=float(entry['PA']))

                # Set metadata
                metadata = ris.set_metadata(meta=metadata,
                                            date=Time(args.date, format='isot') + time_offset,
                                            bandpass=entry['BANDPASS'], sca=sca,
                                            ma_table_number=int(entry['MA_TABLE_NUMBER']))

                # If selected, apply persistence
                if args.persistence and entry_idx > 0:
                    # Use previously created file for persistence for each exposure
                    # after the first
                    persist = persistence.Persistence.read(previous_file_name[sca])

                else:
                    persist = persistence.Persistence()

                ris.simulate_image_file(args, metadata, cat, rng, persist, output=output_file_name)

            # Update persistence file if applicable
            if args.persistence:
                previous_file_name[sca] = output_file_name

            # Break the loop if only one detector specified
            if args.sca > 0:
                break
            else:
                sca += 1

        # Add time offset for the next exposure group
        time_offset += (float(entry['DURATION'])) * u.s

    # Close script file if appropriate
    if args.make_script:
        script_file.close()


# Call main if run (as opposed to imported as a module)
if __name__ == "__main__":
    main()
